# -*- coding: utf-8 -*-
"""hackathon-2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11terC7IdNYpq69eruFW9-CIBymgHZY39
"""

!pip install git+https://github.com/robertmartin8/PyPortfolioOpt.git
!pip install bayesian-optimization
!pip install yfinance

from pypfopt import EfficientFrontier, expected_returns, risk_models
from bayes_opt import BayesianOptimization
import yfinance as yf
import pandas as pd
import numpy as np
import time

FILTER_CONFIG = {
    "low": {
        "min_pe": 10, "max_pe": 30,
        "min_alpha": 0.05, "max_beta": 1.0,
        "sectors": ["Technology", "Finance", "Energy", "Banking"],
        "market_caps": ["large"]
    },
    "medium": {
        "min_pe": 10, "max_pe": 40,
        "min_alpha": 0.05, "max_beta": 1.3,
        "sectors": ["Technology", "Finance", "Energy", "Banking", "Auto"],
        "market_caps": ["large", "mid"]
    },
    "high": {
        "min_pe": 5, "max_pe": 50,
        "min_alpha": 0.0, "max_beta": 1.6,
        "sectors": ["Technology", "Finance", "Auto", "Pharma", "Energy"],
        "market_caps": ["large", "mid", "small"]
    }
}

nifty500 = pd.read_csv("/content/ind_nifty500list.csv")
nse_tickers = [symbol + ".NS" for symbol in nifty500["Symbol"].tolist()]

def build_stock_universe(tickers):
    records = []
    for ticker in tickers:
        try:
            info = yf.Ticker(ticker).info
            records.append({
                "ticker": ticker,
                "pe": info.get("trailingPE"),
                "beta": info.get("beta"),
                "sector": info.get("sector"),
                "market_cap": info.get("marketCap")
            })
            time.sleep(0.2)
        except Exception as e:
            print(f"‚ö†Ô∏è Failed for {ticker}: {e}")
    df = pd.DataFrame(records)
    df = df.dropna(subset=["pe", "beta", "sector", "market_cap"])
    return df

STOCK_UNIVERSE = build_stock_universe(nse_tickers[:500])

STOCK_UNIVERSE.head()

# STOCK_UNIVERSE.to_csv("stock_universe.csv", index=False)
# print("‚úÖ STOCK_UNIVERSE saved to stock_universe.csv")

# filename = f"stock_universe.csv"
# STOCK_UNIVERSE.to_csv(filename, index=False)

# toy stock universe
NSE_TICKERS = [
    "INFY.NS", "TCS.NS", "RELIANCE.NS", "WIPRO.NS", "TECHM.NS",
    "HDFCBANK.NS", "ICICIBANK.NS", "AXISBANK.NS", "HINDUNILVR.NS",
    "ITC.NS", "BHARTIARTL.NS", "SBIN.NS", "ADANIENT.NS", "DMART.NS",
    "PIDILITIND.NS", "TATAMOTORS.NS", "BAJAJFINSV.NS", "DIVISLAB.NS",
    "ZYDUSLIFE.NS", "RADICO.NS"
]

def build_stock_universe(ticker_list):
    stock_data = []

    for ticker in ticker_list:
        try:
            info = yf.Ticker(ticker).info
            stock_data.append({
                "ticker": ticker,
                "pe": info.get("trailingPE"),
                "beta": info.get("beta"),
                "sector": info.get("sector"),
                "market_cap": info.get("marketCap"),
            })
            time.sleep(0.2)  # avoid hitting yfinance rate limits
        except Exception as e:
            print(f"Error fetching {ticker}: {e}")

    df = pd.DataFrame(stock_data)

    # Classify by market cap
    def cap_category(mcap):
        if mcap is None:
            return "unknown"
        elif mcap >= 500_000_000_000:
            return "large"
        elif mcap >= 100_000_000_000:
            return "mid"
        else:
            return "small"

    df["cap_category"] = df["market_cap"].apply(cap_category)
    df.dropna(subset=["pe", "beta", "sector", "market_cap"], inplace=True)

    return df.reset_index(drop=True)

# Use this to fetch and cache full data once
STOCK_UNIVERSE = build_stock_universe(NSE_TICKERS)

def get_filtered_stocks(filters):
    df = STOCK_UNIVERSE.copy()

    return df[
        (df["pe"] >= filters["min_pe"]) &
        (df["pe"] <= filters["max_pe"]) &
        (df["beta"] <= filters["max_beta"]) &
        (df["alpha"] >= filters.get("min_alpha", 0)) if "alpha" in df.columns else True &
        (df["sector"].isin(filters["sectors"]))
    ].to_dict(orient="records")

RISK_CAPS = {
    "low": 25,
    "medium": 20,
    "high": 12
}

def get_filtered_stock_meta(filters, max_selected_stocks):
    stock_meta = get_filtered_stocks(filters)

    # Filter out stocks with missing alpha
    stock_meta = [s for s in stock_meta if s.get("alpha") is not None]

    # Limit and sort by alpha if necessary
    if len(stock_meta) > max_selected_stocks:
        stock_meta = sorted(stock_meta, key=lambda x: x["alpha"], reverse=True)[:max_selected_stocks]

    return stock_meta

def fetch_price_data(tickers, start_date, end_date):
    price_data = yf.download(tickers, start=start_date, end=end_date, auto_adjust=True)["Close"]
    return price_data.dropna(axis=1)

def run_portfolio_optimization(mu, S, bounds):
    def optimize_portfolio(max_weight, min_return):
        ef = EfficientFrontier(mu, S)
        ef.add_constraint(lambda w: w <= max_weight)
        ef.add_constraint(lambda w: w >= 0)
        ef.efficient_return(target_return=min_return)
        return ef.portfolio_performance(verbose=False)[2]

    def objective(max_weight, min_return):
        try:
            return optimize_portfolio(max_weight, min_return)
        except:
            return -1

    optimizer = BayesianOptimization(f=objective, pbounds=bounds, random_state=42, verbose=0)
    optimizer.maximize(init_points=5, n_iter=10)
    return optimizer.max["params"]

def build_portfolio(mu, S, best_params):
    ef_temp = EfficientFrontier(mu, S)
    ef_temp.add_constraint(lambda w: w <= best_params["max_weight"])
    ef_temp.add_constraint(lambda w: w >= 0)
    max_possible_return = ef_temp._max_return()

    target_return = best_params["min_return"]
    if target_return > max_possible_return:
        print(f"\n‚ö†Ô∏è Requested return ({target_return:.4f}) is above max achievable ({max_possible_return:.4f}). Using max.")
        target_return = max_possible_return * 0.98

    try:
        ef = EfficientFrontier(mu, S)
        ef.add_constraint(lambda w: w <= best_params["max_weight"])
        ef.add_constraint(lambda w: w >= 0)
        ef.efficient_return(target_return=target_return)
    except Exception as e:
        print(f"\n‚ö†Ô∏è Fallback to max Sharpe due to: {e}")
        ef = EfficientFrontier(mu, S)
        ef.add_constraint(lambda w: w <= best_params["max_weight"])
        ef.add_constraint(lambda w: w >= 0)
        ef.max_sharpe()

    return ef.clean_weights(), ef.portfolio_performance(verbose=True)



def run_model_vs_index(risk_category, start_date, end_date, index_symbol="^NSEI", initial_investment=100000):
    print(f"\nRisk Category: {risk_category}")
    filters = FILTER_CONFIG[risk_category]
    print(f"Filters Applied: {filters}")

    max_selected_stocks = RISK_CAPS.get(risk_category, 20)
    stock_meta = get_filtered_stock_meta(filters, max_selected_stocks)
    print(f"{stock_meta=}")
    tickers = [s["ticker"] for s in stock_meta]

    print(f"\n‚úÖ Stocks selected: {tickers}")
    print(f"\nüß† Filtered Stock Info:")
    for s in stock_meta:
        print(s)

    if len(tickers) < 3:
        return "‚ùå Not enough diversified stocks to build a portfolio."

    try:
        price_data = fetch_price_data(tickers, start_date, end_date)
    except Exception as e:
        return f"‚ùå Failed to fetch stock price data: {e}"

    tickers = list(price_data.columns)
    if len(tickers) < 3:
        return "‚ùå Insufficient price data for at least 3 stocks."

    mu = expected_returns.mean_historical_return(price_data)
    S = risk_models.sample_cov(price_data)

    bounds = {
        "max_weight": (0.2, 0.3),
        "min_return": (0.05, 0.20)
    }

    best_params = run_portfolio_optimization(mu, S, bounds)
    final_weights, performance = build_portfolio(mu, S, best_params)

    print("\nüìä Final Portfolio Allocation:")
    for k, v in final_weights.items():
        print(f"{k}: {v * 100:.2f}%")

    # Portfolio return over the period
    weights_vector = pd.Series(final_weights)
    returns = price_data.pct_change().dropna()
    portfolio_growth = (returns @ weights_vector).add(1).cumprod()
    model_return = (portfolio_growth.iloc[-1] - 1) * 100

    # Index comparison
    try:
        index_data = yf.download(index_symbol, start=start_date, end=end_date, auto_adjust=True)
        index_close = index_data["Close"]
        if isinstance(index_close, pd.DataFrame):
            index_close = index_close.iloc[:, 0]
        index_return = ((index_close.iloc[-1] - index_close.iloc[0]) / index_close.iloc[0]) * 100
    except Exception as e:
        print(f"‚ö†Ô∏è Failed to get index data: {e}")
        index_return = None

    print(f"\nüìà Model Return: {model_return:.2f}%")
    if index_return is not None:
        print(f"üìâ Index Return ({index_symbol}): {float(index_return):.2f}%")
    else:
        print(f"üìâ Index Return: ‚ùå Not Available")

    # Stock return breakdown
    print(f"\nüìå Stock Returns in Date Range:")
    for ticker in tickers:
        stock = price_data[ticker]
        ret = ((stock.iloc[-1] - stock.iloc[0]) / stock.iloc[0]) * 100
        print(f"{ticker}: {ret:.2f}%")

    return {
        "portfolio_return_percent": float(model_return),
        "index_return_percent": float(index_return) if index_return is not None else None,
        "weights": final_weights,
        "stocks_selected": tickers
    }

run_model_vs_index("medium", "2023-06-01", "2024-01-01")